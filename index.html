<html><head>
        <title>Solar System</title>
        <meta http-equiv="content-type" content="text/html; charset=windows-1252">

        <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
        <script src="//code.jquery.com/jquery-migrate-1.2.1.min.js"></script>
        <script src="js/cloudflare.js" async=""></script><script type="text/javascript">
        //<![CDATA[
            try {
                if (!window.CloudFlare) {
                    var CloudFlare = [{verbose: 0, p: 0, byc: 0, owlid: "cf", bag2: 1, mirage2: 0, oracle: 0, paths: {cloudflare: "/cdn-cgi/nexp/dok2v=1613a3a185/"}, atok: "6b83cf5b62a47567db6147a85d7a334f", petok: "c43c384843c7d49bc368aec01b567ee51df55470-1416081550-1800", zone: "learningwebgl.com", rocket: "0", apps: {}}];
                    CloudFlare.push({"apps": {"ape": "789b85adafda030b65a1e855f79c359b"}});
                    !function (a, b) {
                        a = document.createElement("script"), b = document.getElementsByTagName("script")[0], a.async = !0, a.src = "//ajax.cloudflare.com/cdn-cgi/nexp/dok2v=919620257c/cloudflare.min.js", b.parentNode.insertBefore(a, b)
                    }()
                }
            } catch (e) {
            }
            ;
        //]]>
        </script><style type="text/css">.cf-hidden { display: none; } .cf-invisible { visibility: hidden; } canvas { background:url(stars-notdistorted.png) }
        button{padding:0px; margin: 0px;}
        .zoom-in{background-image: url('zoomin.png'); height: 55px; width: 55px; position: fixed; top: 30px; left: 15px;}
        .zoom-out{background-image: url('zoomout.png'); height: 55px; width: 55px; position: fixed; top: 90px; left: 15px;}
        .pause{background-image: url('pause.png'); height: 55px; width: 55px; position: fixed; top: 30px; right: 15px;}
        .play{background-image: url('play.png'); height: 55px; width: 55px; position: fixed; top: 30px; right: 15px;}
        </style>
        <script type="text/javascript" src="js/glMatrix-0.js"></script>
        <script type="text/javascript" src="js/webgl-utils.js"></script>

        <script id="per-fragment-lighting-fs" type="x-shader/x-fragment">
            precision mediump float;

            varying vec2 vTextureCoord;
            varying vec3 vTransformedNormal;
            varying vec4 vPosition;

            uniform vec3 uMaterialAmbientColor;
            uniform vec3 uMaterialDiffuseColor;
            uniform vec3 uMaterialSpecularColor;
            uniform float uMaterialShininess;
            uniform vec3 uMaterialEmissiveColor;

            uniform bool uShowSpecularHighlights;
            uniform bool uUseTextures;

            uniform vec3 uAmbientLightingColor;

            uniform vec3 uPointLightingLocation;
            uniform vec3 uPointLightingDiffuseColor;
            uniform vec3 uPointLightingSpecularColor;

            uniform sampler2D uSampler;

            void main(void) {
                vec3 ambientLightWeighting = uAmbientLightingColor;

                vec3 lightDirection = normalize(uPointLightingLocation - vPosition.xyz);
                vec3 normal = normalize(vTransformedNormal);

                vec3 specularLightWeighting = vec3(0.0, 0.0, 0.0);
                if (uShowSpecularHighlights) {
                    vec3 eyeDirection = normalize(-vPosition.xyz);
                    vec3 reflectionDirection = reflect(-lightDirection, normal);

                    float specularLightBrightness = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
                    specularLightWeighting = uPointLightingSpecularColor * specularLightBrightness;
                }

                float diffuseLightBrightness = max(dot(normal, lightDirection), 0.0);
                vec3 diffuseLightWeighting = uPointLightingDiffuseColor * diffuseLightBrightness;

                vec3 materialAmbientColor = uMaterialAmbientColor;
                vec3 materialDiffuseColor = uMaterialDiffuseColor;
                vec3 materialSpecularColor = uMaterialSpecularColor;
                vec3 materialEmissiveColor = uMaterialEmissiveColor;
                float alpha = 1.0;
                if (uUseTextures) {
                    vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
                    materialAmbientColor = materialAmbientColor * textureColor.rgb;
                    materialDiffuseColor = materialDiffuseColor * textureColor.rgb;
                    materialEmissiveColor = materialEmissiveColor * textureColor.rgb;
                    alpha = textureColor.a;
                }
                gl_FragColor = vec4(
                    materialAmbientColor * ambientLightWeighting
                    + materialDiffuseColor * diffuseLightWeighting
                    + materialSpecularColor * specularLightWeighting
                    + materialEmissiveColor,
                    alpha
                );
            }
        </script>

        <script id="per-fragment-lighting-vs" type="x-shader/x-vertex">
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;
            attribute vec2 aTextureCoord;

            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;
            uniform mat3 uNMatrix;

            varying vec2 vTextureCoord;
            varying vec3 vTransformedNormal;
            varying vec4 vPosition;


            void main(void) {
                vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
                gl_Position = uPMatrix * vPosition;
                vTextureCoord = aTextureCoord;
                vTransformedNormal = uNMatrix * aVertexNormal;
            }
        </script>


        <script type="text/javascript">

            var gl;

            function initGL(canvas) {
                try {
                    gl = canvas.getContext("experimental-webgl");
                    gl.viewportWidth = canvas.width;
                    gl.viewportHeight = canvas.height;
                } catch (e) {
                }
                if (!gl) {
                    alert("Could not initialise WebGL, sorry :-(");
                }
            }


            function getShader(gl, id) {
                var shaderScript = document.getElementById(id);
                if (!shaderScript) {
                    return null;
                }

                var str = "";
                var k = shaderScript.firstChild;
                while (k) {
                    if (k.nodeType == 3) {
                        str += k.textContent;
                    }
                    k = k.nextSibling;
                }

                var shader;
                if (shaderScript.type == "x-shader/x-fragment") {
                    shader = gl.createShader(gl.FRAGMENT_SHADER);
                } else if (shaderScript.type == "x-shader/x-vertex") {
                    shader = gl.createShader(gl.VERTEX_SHADER);
                } else {
                    return null;
                }

                gl.shaderSource(shader, str);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    alert(gl.getShaderInfoLog(shader));
                    return null;
                }

                return shader;
            }


            var shaderProgram;

            function initShaders() {
                var fragmentShader = getShader(gl, "per-fragment-lighting-fs");
                var vertexShader = getShader(gl, "per-fragment-lighting-vs");

                shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);

                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    alert("Could not initialise shaders");
                }

                gl.useProgram(shaderProgram);

                shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
                gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

                shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
                gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

                shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
                gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

                shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
                shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
                shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
                shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");

                shaderProgram.materialAmbientColorUniform = gl.getUniformLocation(shaderProgram, "uMaterialAmbientColor");
                shaderProgram.materialDiffuseColorUniform = gl.getUniformLocation(shaderProgram, "uMaterialDiffuseColor");
                shaderProgram.materialSpecularColorUniform = gl.getUniformLocation(shaderProgram, "uMaterialSpecularColor");
                shaderProgram.materialShininessUniform = gl.getUniformLocation(shaderProgram, "uMaterialShininess");
                shaderProgram.materialEmissiveColorUniform = gl.getUniformLocation(shaderProgram, "uMaterialEmissiveColor");
                shaderProgram.showSpecularHighlightsUniform = gl.getUniformLocation(shaderProgram, "uShowSpecularHighlights");
                shaderProgram.useTexturesUniform = gl.getUniformLocation(shaderProgram, "uUseTextures");
                shaderProgram.ambientLightingColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientLightingColor");
                shaderProgram.pointLightingLocationUniform = gl.getUniformLocation(shaderProgram, "uPointLightingLocation");
                shaderProgram.pointLightingSpecularColorUniform = gl.getUniformLocation(shaderProgram, "uPointLightingSpecularColor");
                shaderProgram.pointLightingDiffuseColorUniform = gl.getUniformLocation(shaderProgram, "uPointLightingDiffuseColor");
            }
            
            var mouseDown = false;
            var lastMouseX = null;
            var lastMouseY = null;

            var rotationMatrix = mat4.create();
            mat4.identity(rotationMatrix);

            function handleMouseDown(event) {
                mouseDown = true;
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }


            function handleMouseUp(event) {
                mouseDown = false;
            }


            function handleMouseMove(event) {
                if (!mouseDown) {
                    return;
                }
                var newX = event.clientX;
                var newY = event.clientY;

                var deltaX = newX - lastMouseX
                var newRotationMatrix = mat4.create();
                mat4.identity(newRotationMatrix);
                mat4.rotate(newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);

                var deltaY = newY - lastMouseY;
                mat4.rotate(newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);

                mat4.multiply(newRotationMatrix, rotationMatrix, rotationMatrix);

                lastMouseX = newX
                lastMouseY = newY;
            }
            
            var z=-5.0;

            function handleMouseWheel(event){
                var delta = 0;
                if (!event) /* For IE. */
                    event = window.event;
                if (event.wheelDelta) { /* IE/Opera. */
                    delta = event.wheelDelta/120;
                } else if (event.detail) { /** Mozilla case. */
                    /** In Mozilla, sign of delta is different than in IE.
                    * Also, delta is multiple of 3.
                    */
                    delta = -event.detail/3;
                }
                /** If delta is nonzero, handle it.
                * Basically, delta is now positive if wheel was scrolled up,
                * and negative, if wheel was scrolled down.
                */
                if (delta)
                    handleScroll(delta);
                /** Prevent default actions caused by mouse wheel.
                * That might be ugly, but we handle scrolls somehow
                * anyway, so don’t bother here..
                */
                if (event.preventDefault)
                    event.preventDefault();
                event.returnValue = false;
            }

            function handleScroll(delta) {
                if (delta < 0)
                    z=z-1;
                else
                    z=z+1;
            }
            
            function handleScrollButton(delta) {
                if (delta < 0)
                    z=z-3;
                else
                    z=z+3;
            }


            function handleLoadedTexture(texture) {
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                gl.generateMipmap(gl.TEXTURE_2D);

                gl.bindTexture(gl.TEXTURE_2D, null);
            }


            //Texture vars
            var sunTexture;
            var mercuryTexture;
            var venusTexture;
            var earthTexture;
            var moonTexture;
            var marsTexture;
            var jupiterTexture;
            var saturnTexture;
            var neptuneTexture;
            var uranusTexture;
            var saturnRingsTexture;
            var uranusRingsTexture;

            function initTextures() {
                //Sun texture
                sunTexture = gl.createTexture();
                sunTexture.image = new Image();
                sunTexture.image.onload = function () {
                    handleLoadedTexture(sunTexture)
                }
                sunTexture.image.src = "sunmap.jpg";
                
                //Mercury texture
                mercuryTexture = gl.createTexture();
                mercuryTexture.image = new Image();
                mercuryTexture.image.onload = function () {
                    handleLoadedTexture(mercuryTexture)
                }
                mercuryTexture.image.src = "mercurymap.jpg";
                
                //Venus texture
                venusTexture = gl.createTexture();
                venusTexture.image = new Image();
                venusTexture.image.onload = function () {
                    handleLoadedTexture(venusTexture)
                }
                venusTexture.image.src = "venusmap.jpg";
                
                //Earth texture
                earthTexture = gl.createTexture();
                earthTexture.image = new Image();
                earthTexture.image.onload = function () {
                    handleLoadedTexture(earthTexture)
                }
                earthTexture.image.src = "earthmap1k.jpg";
                
                //Moon texture
                moonTexture = gl.createTexture();
                moonTexture.image = new Image();
                moonTexture.image.onload = function () {
                    handleLoadedTexture(moonTexture)
                }
                moonTexture.image.src = "moon.jpg";
                
                //Mars texture
                marsTexture = gl.createTexture();
                marsTexture.image = new Image();
                marsTexture.image.onload = function () {
                    handleLoadedTexture(marsTexture)
                }
                marsTexture.image.src = "marsmap1k.jpg";
                
                //Jupiter texture
                jupiterTexture = gl.createTexture();
                jupiterTexture.image = new Image();
                jupiterTexture.image.onload = function () {
                    handleLoadedTexture(jupiterTexture)
                }
                jupiterTexture.image.src = "jupitermap.jpg";
                
                //Saturn texture
                saturnTexture = gl.createTexture();
                saturnTexture.image = new Image();
                saturnTexture.image.onload = function () {
                    handleLoadedTexture(saturnTexture)
                }
                saturnTexture.image.src = "saturnmap.jpg";
                
                //Neptune texture
                neptuneTexture = gl.createTexture();
                neptuneTexture.image = new Image();
                neptuneTexture.image.onload = function () {
                    handleLoadedTexture(neptuneTexture)
                }
                neptuneTexture.image.src = "neptunemap.jpg";
                
                //Uranus texture
                uranusTexture = gl.createTexture();
                uranusTexture.image = new Image();
                uranusTexture.image.onload = function () {
                    handleLoadedTexture(uranusTexture)
                }
                uranusTexture.image.src = "uranusmap.jpg";
                
                //Saturn Rings texture
                saturnRingsTexture = gl.createTexture();
                saturnRingsTexture.image = new Image();
                saturnRingsTexture.image.onload = function () {
                    handleLoadedTexture(saturnRingsTexture)
                }
                saturnRingsTexture.image.src = "ringsRGBA.png";
                
                //Uranus Rings texture
                uranusRingsTexture = gl.createTexture();
                uranusRingsTexture.image = new Image();
                uranusRingsTexture.image.onload = function () {
                    handleLoadedTexture(uranusRingsTexture)
                }
                uranusRingsTexture.image.src = "uranusrings.png";
            }


            var mvMatrix = mat4.create();
            var mvMatrixStack = [];
            var pMatrix = mat4.create();

            function mvPushMatrix() {
                var copy = mat4.create();
                mat4.set(mvMatrix, copy);
                mvMatrixStack.push(copy);
            }

            function mvPopMatrix() {
                if (mvMatrixStack.length == 0) {
                    throw "Invalid popMatrix!";
                }
                mvMatrix = mvMatrixStack.pop();
            }

            function setMatrixUniforms() {
                gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
                gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);

                var normalMatrix = mat3.create();
                mat4.toInverseMat3(mvMatrix, normalMatrix);
                mat3.transpose(normalMatrix);
                gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
            }

            function degToRad(degrees) {
                return degrees * Math.PI / 180;
            }

            //Sun Vars
            var sunVertexPositionBuffer;
            var sunVertexNormalBuffer;
            var sunVertexTextureCoordBuffer;
            var sunVertexIndexBuffer;
            //Mercury Vars
            var mercuryVertexPositionBuffer;
            var mercuryVertexNormalBuffer;
            var mercuryVertexTextureCoordBuffer;
            var mercuryVertexIndexBuffer;
            //Venus Vars
            var venusVertexPositionBuffer;
            var venusVertexNormalBuffer;
            var venusVertexTextureCoordBuffer;
            var venusVertexIndexBuffer;
            //Earth Vars
            var earthVertexPositionBuffer;
            var earthVertexNormalBuffer;
            var earthVertexTextureCoordBuffer;
            var earthVertexIndexBuffer;
            //Moon Vars
            var moonVertexPositionBuffer;
            var moonVertexNormalBuffer;
            var moonVertexTextureCoordBuffer;
            var moonVertexIndexBuffer;
            //Mars Vars
            var marsVertexPositionBuffer;
            var marsVertexNormalBuffer;
            var marsVertexTextureCoordBuffer;
            var marsVertexIndexBuffer;
            //Jupiter Vars
            var jupiterVertexPositionBuffer;
            var jupiterVertexNormalBuffer;
            var jupiterVertexTextureCoordBuffer;
            var jupiterVertexIndexBuffer;
            //Saturn Vars
            var saturnVertexPositionBuffer;
            var saturnVertexNormalBuffer;
            var saturnVertexTextureCoordBuffer;
            var saturnVertexIndexBuffer;
            //Neptune Vars
            var neptuneVertexPositionBuffer;
            var neptuneVertexNormalBuffer;
            var neptuneVertexTextureCoordBuffer;
            var neptuneVertexIndexBuffer;
            //Uranus Vars
            var uranusVertexPositionBuffer;
            var uranusVertexNormalBuffer;
            var uranusVertexTextureCoordBuffer;
            var uranusVertexIndexBuffer;
            //Rings Vars
            var saturnRingsVertexPositionBuffer;
            var saturnRingsVertexNormalBuffer;
            var saturnRingsVertexTextureCoordBuffer;
            var saturnRingsVertexIndexBuffer;
            //Rings Vars
            var uranusRingsVertexPositionBuffer;
            var uranusRingsVertexNormalBuffer;
            var uranusRingsVertexTextureCoordBuffer;
            var uranusRingsVertexIndexBuffer;

            var vertexPositionBuffer;
            var vertexNormalBuffer;
            var vertexTextureCoordBuffer;
            var vertexIndexBuffer;

            function initBuffers(planet, rad) {
                var latitudeBands = 30;
                var longitudeBands = 30;
                var radius = rad;

                var vertexPositionData = [];
                var normalData = [];
                var textureCoordData = [];
                if(planet == "saturnRings"){
                    saturnRingsVertexPositionBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, saturnRingsVertexPositionBuffer);
                    vertices = [
                        -1.0,  1.0, -1.0,
                        -1.0,  1.0,  1.0,
                        1.0,  1.0,  1.0,
                        1.0,  1.0, -1.0
                    ];
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                    saturnRingsVertexPositionBuffer.itemSize = 3;
                    saturnRingsVertexPositionBuffer.numItems = 4;

                    saturnRingsVertexNormalBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, saturnRingsVertexNormalBuffer);
                    var vertexNormals = [
                        0.0,  1.0,  0.0,
                        0.0,  1.0,  0.0,
                        0.0,  1.0,  0.0,
                        0.0,  1.0,  0.0
                    ];
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);
                    saturnRingsVertexNormalBuffer.itemSize = 3;
                    saturnRingsVertexNormalBuffer.numItems = 4;

                    saturnRingsVertexTextureCoordBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, saturnRingsVertexTextureCoordBuffer);
                    var textureCoords = [
                        0.0, 1.0,
                        0.0, 0.0,
                        1.0, 0.0,
                        1.0, 1.0
                    ];
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
                    saturnRingsVertexTextureCoordBuffer.itemSize = 2;
                    saturnRingsVertexTextureCoordBuffer.numItems = 4;

                    saturnRingsVertexIndexBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, saturnRingsVertexIndexBuffer);
                    var cubeVertexIndices = [
                        0, 1, 2,      0, 2, 3    
                    ];
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
                    saturnRingsVertexIndexBuffer.itemSize = 1;
                    saturnRingsVertexIndexBuffer.numItems = 6;
                }else if(planet == "uranusRings"){
                    uranusRingsVertexPositionBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, uranusRingsVertexPositionBuffer);
                    vertices = [
                        -1.0, -1.0,  1.0,
                        1.0, -1.0,  1.0,
                        1.0,  1.0,  1.0,
                       -1.0,  1.0,  1.0
                    ];
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                    uranusRingsVertexPositionBuffer.itemSize = 3;
                    uranusRingsVertexPositionBuffer.numItems = 4;

                    uranusRingsVertexNormalBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, uranusRingsVertexNormalBuffer);
                    var vertexNormals = [
                        0.0,  0.0,  1.0,
                        0.0,  0.0,  1.0,
                        0.0,  0.0,  1.0,
                        0.0,  0.0,  1.0
                    ];
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);
                    uranusRingsVertexNormalBuffer.itemSize = 3;
                    uranusRingsVertexNormalBuffer.numItems = 4;

                    uranusRingsVertexTextureCoordBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, uranusRingsVertexTextureCoordBuffer);
                    var textureCoords = [
                        0.0, 0.0,
                        1.0, 0.0,
                        1.0, 1.0,
                        0.0, 1.0
                    ];
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
                    uranusRingsVertexTextureCoordBuffer.itemSize = 2;
                    uranusRingsVertexTextureCoordBuffer.numItems = 4;

                    uranusRingsVertexIndexBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, uranusRingsVertexIndexBuffer);
                    var cubeVertexIndices = [
                        0, 1, 2,      0, 2, 3
                    ];
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
                    uranusRingsVertexIndexBuffer.itemSize = 1;
                    uranusRingsVertexIndexBuffer.numItems = 6;
                }else{
                    for (var latNumber = 0; latNumber <= latitudeBands; latNumber++) {
                        var theta = latNumber * Math.PI / latitudeBands;
                        var sinTheta = Math.sin(theta);
                        var cosTheta = Math.cos(theta);

                        for (var longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                            var phi = longNumber * 2 * Math.PI / longitudeBands;
                            var sinPhi = Math.sin(phi);
                            var cosPhi = Math.cos(phi);

                            var x = cosPhi * sinTheta;
                            var y = cosTheta;
                            var z = sinPhi * sinTheta;
                            var u = 1 - (longNumber / longitudeBands);
                            var v = 1 - (latNumber / latitudeBands);

                            normalData.push(x);
                            normalData.push(y);
                            normalData.push(z);
                            textureCoordData.push(u);
                            textureCoordData.push(v);
                            vertexPositionData.push(radius * x);
                            vertexPositionData.push(radius * y);
                            vertexPositionData.push(radius * z);
                        }
                    }

                    var indexData = [];
                    for (var latNumber = 0; latNumber < latitudeBands; latNumber++) {
                        for (var longNumber = 0; longNumber < longitudeBands; longNumber++) {
                            var first = (latNumber * (longitudeBands + 1)) + longNumber;
                            var second = first + longitudeBands + 1;
                            indexData.push(first);
                            indexData.push(second);
                            indexData.push(first + 1);

                            indexData.push(second);
                            indexData.push(second + 1);
                            indexData.push(first + 1);
                        }
                    }

                    vertexNormalBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalData), gl.STATIC_DRAW);
                    vertexNormalBuffer.itemSize = 3;
                    vertexNormalBuffer.numItems = normalData.length / 3;

                    vertexTextureCoordBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, vertexTextureCoordBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordData), gl.STATIC_DRAW);
                    vertexTextureCoordBuffer.itemSize = 2;
                    vertexTextureCoordBuffer.numItems = textureCoordData.length / 2;

                    vertexPositionBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
                    vertexPositionBuffer.itemSize = 3;
                    vertexPositionBuffer.numItems = vertexPositionData.length / 3;

                    vertexIndexBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndexBuffer);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
                    vertexIndexBuffer.itemSize = 1;
                    vertexIndexBuffer.numItems = indexData.length;
                }
                
                if(planet == "sun"){
                    sunVertexPositionBuffer = vertexPositionBuffer;
                    sunVertexNormalBuffer = vertexNormalBuffer;
                    sunVertexTextureCoordBuffer = vertexTextureCoordBuffer;
                    sunVertexIndexBuffer = vertexIndexBuffer;
                }else if(planet == "mercury"){
                    mercuryVertexPositionBuffer = vertexPositionBuffer;
                    mercuryVertexNormalBuffer = vertexNormalBuffer;
                    mercuryVertexTextureCoordBuffer = vertexTextureCoordBuffer;
                    mercuryVertexIndexBuffer = vertexIndexBuffer;
                }else if(planet == "venus"){
                    venusVertexPositionBuffer = vertexPositionBuffer;
                    venusVertexNormalBuffer = vertexNormalBuffer;
                    venusVertexTextureCoordBuffer = vertexTextureCoordBuffer;
                    venusVertexIndexBuffer = vertexIndexBuffer;
                }else if(planet == "earth"){
                    earthVertexPositionBuffer = vertexPositionBuffer;
                    earthVertexNormalBuffer = vertexNormalBuffer;
                    earthVertexTextureCoordBuffer = vertexTextureCoordBuffer;
                    earthVertexIndexBuffer = vertexIndexBuffer;
                }else if(planet == "moon"){
                    moonVertexPositionBuffer = vertexPositionBuffer;
                    moonVertexNormalBuffer = vertexNormalBuffer;
                    moonVertexTextureCoordBuffer = vertexTextureCoordBuffer;
                    moonVertexIndexBuffer = vertexIndexBuffer;
                }else if(planet == "mars"){
                    marsVertexPositionBuffer = vertexPositionBuffer;
                    marsVertexNormalBuffer = vertexNormalBuffer;
                    marsVertexTextureCoordBuffer = vertexTextureCoordBuffer;
                    marsVertexIndexBuffer = vertexIndexBuffer;
                }else if(planet == "jupiter"){
                    jupiterVertexPositionBuffer = vertexPositionBuffer;
                    jupiterVertexNormalBuffer = vertexNormalBuffer;
                    jupiterVertexTextureCoordBuffer = vertexTextureCoordBuffer;
                    jupiterVertexIndexBuffer = vertexIndexBuffer;
                }else if(planet == "saturn"){
                    saturnVertexPositionBuffer = vertexPositionBuffer;
                    saturnVertexNormalBuffer = vertexNormalBuffer;
                    saturnVertexTextureCoordBuffer = vertexTextureCoordBuffer;
                    saturnVertexIndexBuffer = vertexIndexBuffer;
                }else if(planet == "neptune"){
                    neptuneVertexPositionBuffer = vertexPositionBuffer;
                    neptuneVertexNormalBuffer = vertexNormalBuffer;
                    neptuneVertexTextureCoordBuffer = vertexTextureCoordBuffer;
                    neptuneVertexIndexBuffer = vertexIndexBuffer;
                }else if(planet == "uranus"){
                    uranusVertexPositionBuffer = vertexPositionBuffer;
                    uranusVertexNormalBuffer = vertexNormalBuffer;
                    uranusVertexTextureCoordBuffer = vertexTextureCoordBuffer;
                    uranusVertexIndexBuffer = vertexIndexBuffer;
                }
            }



            var earthAngle = 0;
            var earthAbotuSunAngle = 0;
            var sunAngle = 0;
            var mercuryAngle = 0;
            var mercuryAbotuSunAngle = 0;
            var venusAngle = 0;
            var venusAbotuSunAngle = 0;
            var marsAngle = 0;
            var marsAbotuSunAngle = 0;
            var jupiterAngle = 0;
            var jupiterAbotuSunAngle = 0;
            var saturnAngle = 0;
            var saturnAbotuSunAngle = 0;
            var neptuneAngle = 0;
            var neptuneAbotuSunAngle = 0;
            var uranusAngle = 0;
            var uranusAbotuSunAngle = 0;

            function drawScene() {
                gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
                gl.disable(gl.BLEND);

                mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

                mat4.identity(mvMatrix);
                //Zoom
                mat4.translate(mvMatrix, [0.0, 0.0, z]);
                mat4.multiply(mvMatrix, rotationMatrix);
                
                //Lighting
                gl.uniform1i(shaderProgram.showSpecularHighlightsUniform, true);
                gl.uniform1i(shaderProgram.useTexturesUniform, true);
                gl.uniform3f(shaderProgram.pointLightingLocationUniform, 0, 0, -10);
                gl.uniform3f(shaderProgram.ambientLightingColorUniform, 0.2, 0.2, 0.2);
                gl.uniform3f(shaderProgram.pointLightingDiffuseColorUniform, 1.8, 1.8, 1.8);
                gl.uniform3f(shaderProgram.pointLightingSpecularColorUniform, 0.8, 0.8, 0.8);
                //Phong
                gl.uniform3f(shaderProgram.materialAmbientColorUniform, 1.0, 1.0, 1.0);
                gl.uniform3f(shaderProgram.materialDiffuseColorUniform, 1.0, 1.0, 1.0);
                gl.uniform3f(shaderProgram.materialSpecularColorUniform, 1.0, 1.0, 1.0);
                gl.uniform1f(shaderProgram.materialShininessUniform, 5);
                //Make sun emissive
                gl.uniform3f(shaderProgram.materialEmissiveColorUniform, 1.0, 1.0, 1.0);

                //Sun
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, sunTexture);
                
                mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);
                mvPushMatrix();
                mat4.rotate(mvMatrix, degToRad(sunAngle), [0, 1, 0]);
                gl.bindBuffer(gl.ARRAY_BUFFER, sunVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, sunVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, sunVertexTextureCoordBuffer);
                gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, sunVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, sunVertexNormalBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, sunVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sunVertexIndexBuffer);
                setMatrixUniforms();
                gl.drawElements(gl.TRIANGLES, sunVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                mvPopMatrix();
                //Make the rest of the planets non-emissive
                gl.uniform3f(shaderProgram.materialEmissiveColorUniform, 0.0, 0.0, 0.0);
                
                //Mercury
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, mercuryTexture);
                
                mvPushMatrix();
                mat4.rotate(mvMatrix, degToRad(mercuryAbotuSunAngle), [0, 1, 0]);
                mat4.translate(mvMatrix, [-3.5, 0.0, 0.0]);
                mat4.rotate(mvMatrix, degToRad(0.034), [1, 0, -1]);
                mat4.rotate(mvMatrix, degToRad(mercuryAngle), [0, 1, 0]);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, mercuryVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, mercuryVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, mercuryVertexTextureCoordBuffer);
                gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, mercuryVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, mercuryVertexNormalBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, mercuryVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mercuryVertexIndexBuffer);
                setMatrixUniforms();
                gl.drawElements(gl.TRIANGLES, mercuryVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                mvPopMatrix();
                
                //Venus
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, venusTexture);
                
                mvPushMatrix();
                mat4.rotate(mvMatrix, degToRad(venusAbotuSunAngle), [0, 1, 0]);
                mat4.translate(mvMatrix, [-5.5, 0.0, 0.0]);
                mat4.rotate(mvMatrix, degToRad(177.36), [1, 0, -1]);
                mat4.rotate(mvMatrix, degToRad(venusAngle), [0, 1, 0]);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, venusVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, venusVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, venusVertexTextureCoordBuffer);
                gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, venusVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, venusVertexNormalBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, venusVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, venusVertexIndexBuffer);
                setMatrixUniforms();
                gl.drawElements(gl.TRIANGLES, venusVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                mvPopMatrix();
                
                //Earth
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, earthTexture);
                
                mvPushMatrix();
                mat4.rotate(mvMatrix, degToRad(earthAbotuSunAngle), [0, 1, 0]);
                mat4.translate(mvMatrix, [-8.0, 0.0, 0.0]);
                mat4.rotate(mvMatrix, degToRad(earthAngle), [0, 1, 0]);
                mvPushMatrix();
                mat4.rotate(mvMatrix, degToRad(23.4), [1, 0, -1]);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, earthVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, earthVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, earthVertexTextureCoordBuffer);
                gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, earthVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, earthVertexNormalBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, earthVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, earthVertexIndexBuffer);
                setMatrixUniforms();
                gl.drawElements(gl.TRIANGLES, earthVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                mvPopMatrix();

                //Moon
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, moonTexture);
                
                mat4.translate(mvMatrix, [1.0, 0.0, 0.0]);
                gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, moonVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexTextureCoordBuffer);
                gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, moonVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, moonVertexNormalBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, moonVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, moonVertexIndexBuffer);
                setMatrixUniforms();
                gl.drawElements(gl.TRIANGLES, moonVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                mvPopMatrix();
                
                //Mars
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, marsTexture);
                
                mvPushMatrix();
                mat4.rotate(mvMatrix, degToRad(marsAbotuSunAngle), [0, 1, 0]);
                mat4.translate(mvMatrix, [-11.0, 0.0, 0.0]);
                mat4.rotate(mvMatrix, degToRad(25.19), [1, 0, -1]);
                mat4.rotate(mvMatrix, degToRad(marsAngle), [0, 1, 0]);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, marsVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, marsVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, marsVertexTextureCoordBuffer);
                gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, marsVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, marsVertexNormalBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, marsVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, marsVertexIndexBuffer);
                setMatrixUniforms();
                gl.drawElements(gl.TRIANGLES, marsVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                mvPopMatrix();
                
                //Jupiter
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, jupiterTexture);
                
                mvPushMatrix();
                mat4.rotate(mvMatrix, degToRad(jupiterAbotuSunAngle), [0, 1, 0]);
                mat4.translate(mvMatrix, [-22.0, 0.0, 0.0]);
                mat4.rotate(mvMatrix, degToRad(3.13), [1, 0, -1]);
                mat4.rotate(mvMatrix, degToRad(jupiterAngle), [0, 1, 0]);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, jupiterVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, jupiterVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, jupiterVertexTextureCoordBuffer);
                gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, jupiterVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, jupiterVertexNormalBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, jupiterVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, jupiterVertexIndexBuffer);
                setMatrixUniforms();
                gl.drawElements(gl.TRIANGLES, jupiterVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                mvPopMatrix();
                
                //Saturn
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, saturnTexture);
                
                mvPushMatrix();
                mat4.rotate(mvMatrix, degToRad(saturnAbotuSunAngle), [0, 1, 0]);
                mat4.translate(mvMatrix, [-28.0, 0.0, 0.0]);
                mat4.rotate(mvMatrix, degToRad(26.73), [1, 0, -1]);
                mat4.rotate(mvMatrix, degToRad(saturnAngle), [0, 1, 0]);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, saturnVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, saturnVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, saturnVertexTextureCoordBuffer);
                gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, saturnVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, saturnVertexNormalBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, saturnVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, saturnVertexIndexBuffer);
                setMatrixUniforms();
                gl.drawElements(gl.TRIANGLES, saturnVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                mvPopMatrix();
                
                //Uranus
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, uranusTexture);
                
                mvPushMatrix();
                mat4.rotate(mvMatrix, degToRad(uranusAbotuSunAngle), [0, 1, 0]);
                mat4.translate(mvMatrix, [-32.0, 0.0, 0.0]);
                mat4.rotate(mvMatrix, degToRad(97.77), [1, 0, -1]);
                mat4.rotate(mvMatrix, degToRad(uranusAngle), [0, 1, 0]);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, uranusVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, uranusVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, uranusVertexTextureCoordBuffer);
                gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, uranusVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, uranusVertexNormalBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, uranusVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, uranusVertexIndexBuffer);
                setMatrixUniforms();
                gl.drawElements(gl.TRIANGLES, uranusVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                mvPopMatrix();
                
                //Neptune
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, neptuneTexture);
                
                mvPushMatrix();
                mat4.rotate(mvMatrix, degToRad(neptuneAbotuSunAngle), [0, 1, 0]);
                mat4.translate(mvMatrix, [-38.0, 0.0, 0.0]);
                mat4.rotate(mvMatrix, degToRad(28.32), [1, 0, -1]);
                mat4.rotate(mvMatrix, degToRad(neptuneAngle), [0, 1, 0]);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, neptuneVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, neptuneVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, neptuneVertexTextureCoordBuffer);
                gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, neptuneVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, neptuneVertexNormalBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, neptuneVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, neptuneVertexIndexBuffer);
                setMatrixUniforms();
                gl.drawElements(gl.TRIANGLES, neptuneVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                mvPopMatrix();
                
                //Saturn Rings
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, saturnRingsTexture);
                
                mvPushMatrix();
                mat4.rotate(mvMatrix, degToRad(saturnAbotuSunAngle), [0, 1, 0]);
                mat4.translate(mvMatrix, [-28.5, -1.7, -0.5]);
                mat4.rotate(mvMatrix, degToRad(26.73), [1, 0, -1]);
                mat4.scale(mvMatrix, [2, 2, 2]);
                mat4.rotate(mvMatrix, degToRad(saturnAngle), [0, 1, 0]);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, saturnRingsVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, saturnRingsVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, saturnRingsVertexTextureCoordBuffer);
                gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, saturnRingsVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, saturnRingsVertexNormalBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, saturnRingsVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
               
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                gl.enable(gl.BLEND);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, saturnRingsVertexIndexBuffer);
                setMatrixUniforms();
                gl.drawElements(gl.TRIANGLES, saturnRingsVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                mvPopMatrix();
                
                //Uranus Rings
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, uranusRingsTexture);
                
                mvPushMatrix();
                mat4.rotate(mvMatrix, degToRad(uranusAbotuSunAngle), [0, 1, 0]);
                mat4.translate(mvMatrix, [-32.0, 0.0, -1.0]);

                gl.bindBuffer(gl.ARRAY_BUFFER, uranusRingsVertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, uranusRingsVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, uranusRingsVertexTextureCoordBuffer);
                gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, uranusRingsVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, uranusRingsVertexNormalBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, uranusRingsVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, uranusRingsVertexIndexBuffer);
                setMatrixUniforms();
                gl.drawElements(gl.TRIANGLES, uranusRingsVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
                
                mvPopMatrix();
            }


            var lastTime = 0;

            function animate() {
                var timeNow = new Date().getTime();
                if (lastTime != 0) {
                    var elapsed = timeNow - lastTime;
                    sunAngle += (20 * elapsed) / 1000.0;
                    
                    mercuryAngle += (0.5 * elapsed) / 1000.0;
                    mercuryAbotuSunAngle += (100 * elapsed) / 1000.0;
                    
                    venusAngle += (0.2 * elapsed) / 1000.0;
                    venusAbotuSunAngle += (33 * elapsed) / 1000.0;
                    
                    earthAngle += (30 * elapsed) / 1000.0;
                    earthAbotuSunAngle += (20 * elapsed) / 1000.0;
                    
                    marsAngle += (30 * elapsed) / 1000.0;
                    marsAbotuSunAngle += (17 * elapsed) / 1000.0;
                    
                    jupiterAngle += (75 * elapsed) / 1000.0;
                    jupiterAbotuSunAngle += (14 * elapsed) / 1000.0;
                    
                    saturnAngle += (68 * elapsed) / 1000.0;
                    saturnAbotuSunAngle += (10 * elapsed) / 1000.0;
                    
                    neptuneAngle+= (44 * elapsed) / 1000.0;
                    neptuneAbotuSunAngle += (3 * elapsed) / 1000.0;
                    
                    uranusAngle += (42 * elapsed) / 1000.0;
                    uranusAbotuSunAngle += (8 * elapsed) / 1000.0;
                    
                }
                lastTime = timeNow;
            }


            function tick() {
                requestAnimFrame(tick);
                drawScene();
                if($('#status').hasClass('pause')){
                    animate();
                }
            }

            var objects = {"sun": 1.5, "mercury": 0.2, "venus": 0.4, "earth": 0.42, "moon": 0.14, "mars": 0.3, "jupiter": 0.9, "saturn": 0.83, "uranus": 0.6, "neptune" : 0.56, "saturnRings": 1, "uranusRings": 1};
            
            function webGLStart() {
                var canvas = document.getElementById("canvas");
                canvas.width = document.body.clientWidth;
                canvas.height = document.body.clientHeight;
                initGL(canvas);
                initShaders();
                $.each(objects, function(key, value){
                    initBuffers(key, value);
                });
                initTextures();

                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.enable(gl.DEPTH_TEST);

                canvas.onmousedown = handleMouseDown;
                document.onmouseup = handleMouseUp;
                document.onmousemove = handleMouseMove;

                if (canvas.addEventListener) {
                    canvas.addEventListener('DOMMouseScroll', handleMouseWheel, false);
                }
                
                $('.zoom-in').click(function(){
                    handleScrollButton(1);
                });
                $('.zoom-out').click(function(){
                    handleScrollButton(-1);
                });
                $('#status').click(function(){
                    if($('#status').hasClass('pause')){
                        $('#status').removeClass("pause").addClass('play');
                    }else{
                        $('#status').removeClass("play").addClass('pause');
                    }
                });

                tick();
            }

        </script>


    </head>


    <body onload="webGLStart();">
        <button class="zoom-in"></button>
        <button class="zoom-out"></button>
        <button id="status" class="pause"></button>
        <canvas id="canvas" style="border: none;" width="500" height="500"></canvas>

    </body></html>